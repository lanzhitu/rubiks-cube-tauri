
# 分步解魔方设计方案（简化版）

---

## 一、核心思路

### 1. 基本原理
- 使用54位字符串表示魔方状态
- 通过状态匹配确定解法进度
- 简单的检查点系统指导用户

### 2. 关键检查点
1. 底层十字（索引0-8区域）
2. 底层完成（索引0-8区域）
3. 中层完成（索引9-35区域）
4. 顶层完成（索引45-53区域）

### 3. 状态表示
```typescript
const SOLVED_STATE = "WWWWWWWWWOOOOOOOOOGGGGGGGGGRRRRRRRRRBBBBBBBBBYYYYYYYYY";
// 索引对应关系：
// 0-8:   顶面（白色）
// 9-17:  左面（橙色）
// 18-26: 前面（绿色）
// 27-35: 右面（红色）
// 36-44: 后面（蓝色）
// ### 3. 简化UI设计
```
+--------------------------------+
|         魔方3D显示             |
|     [可交互的3D魔方模型]       |
+--------------------------------+
|         进度指示器             |
|     [当前进度: 完成底层十字]    |
+--------------------------------+
|         操作提示               |
| 下一步: F R U R'              |
| [执行] [重置] [提示]          |
+--------------------------------+ 2. 前端目录结构
```typescript
// utils/solvingManager.ts
class SolvingManager {
  private state: SolvingState;
  
  ### 2. 解法管理
```typescript
// utils/solvingManager.ts

interface SolvingState {
  currentStep: number;
  solution: string[];
  progress: string;
}

class SolvingManager {
  private state: SolvingState;

  constructor(solution: string[]) {
    this.state = {
      currentStep: 0,
      solution,
      progress: 'IN_PROGRESS'
    };
  }

  // 更新状态
  updateState(cubeState: string) {
    this.state.progress = CubeChecker.getProgress(cubeState);
    return this.getGuide();
  }

  // 获取当前引导信息
  getGuide() {
    return {
      progress: this.state.progress,
      currentStep: this.state.currentStep,
      nextMove: this.state.solution[this.state.currentStep],
      description: this.getDescription()
    };
  }

  private getDescription(): string {
    switch (this.state.progress) {
      case 'BOTTOM_CROSS': return '完成白色面十字';
      case 'BOTTOM_COMPLETE': return '完成白色面';
      case 'MIDDLE_COMPLETE': return '完成中间层';
      case 'SOLVED': return '魔方已还原';
      default: return '继续操作';
    }
  }
}

  moveToNextStage() {
    if (this.state.currentStage < this.state.stages.length - 1) {
      this.state.currentStage++;
      this.state.currentStep = this.state.stages[this.state.currentStage].startStep;
    }
  }

  getCurrentStageGuide(): StageGuide {
    const stage = this.state.stages[this.state.currentStage];
    return {
      stageName: stage.name,
      description: stage.description,
      currentFormula: this.state.formula[this.state.currentStep],
      progress: `${this.state.currentStep + 1}/${this.state.totalSteps}`
    };
  }
}
```

## 二、简化实现

### 1. 状态检测
```typescript
// utils/cubeUtils.ts

// 简单的状态检查器
class CubeChecker {
  // 检查指定区域是否完成
  static checkArea(state: string, start: number, end: number, targetColor: string): boolean {
    const area = state.slice(start, end + 1);
    return area.split('').every(color => color === targetColor);
  }

  // 检查指定位置列表是否匹配目标颜色
  static checkPositions(state: string, positions: number[], targetColor: string): boolean {
    return positions.every(pos => state[pos] === targetColor);
  }

  // 获取当前进度
  static getProgress(state: string): string {
    // 检查底层十字
    if (this.checkPositions(state, [1,3,4,5,7], 'W')) {
      return 'BOTTOM_CROSS';
    }
    // 检查底层完成
    if (this.checkArea(state, 0, 8, 'W')) {
      return 'BOTTOM_COMPLETE';
    }
    // 检查中层
    if (this.checkPositions(state, [10,13,16,19,22,25,28,31,34], 'O')) {
      return 'MIDDLE_COMPLETE';
    }
    // 检查完成
    if (state === SOLVED_STATE) {
      return 'SOLVED';
    }
    return 'IN_PROGRESS';
  }
  // 分析当前魔方状态，返回已完成的阶段
  static analyzeState(state: string): string {
    if (this.isComplete(state)) {
      return 'SOLVED';
    }
    if (this.checkLastLayer(state)) {
      return 'LAST_LAYER_CORNERS';
    }
    if (this.checkTopCrossOriented(state)) {
      return 'TOP_CROSS_ORIENTED';
    }
    if (this.checkTopCross(state)) {
      return 'TOP_CROSS';
    }
    if (this.checkMiddleLayer(state)) {
      return 'MIDDLE_LAYER';
    }
    if (this.checkBottomCorners(state)) {
      return 'BOTTOM_CORNERS';
    }
    if (this.checkBottomCross(state)) {
      return 'BOTTOM_CROSS';
    }
    return 'INITIAL';
  }

  // 检查魔方是否完全还原
  static isComplete(state: string): boolean {
    const faces = parseCubeState(state);
    return Object.values(faces).every(face => 
      face.split('').every(color => color === face[4])
    );
  }

  // 检查底层十字
  static checkBottomCross(state: string): boolean {
    const faces = parseCubeState(state);
    // 检查白色面的十字
    const whiteCross = faces.up[1] === 'W' && 
                      faces.up[3] === 'W' && 
                      faces.up[4] === 'W' && 
                      faces.up[5] === 'W' && 
                      faces.up[7] === 'W';
    // 检查周围颜色
    const sideColors = faces.front[1] === 'G' &&
                      faces.right[1] === 'R' &&
                      faces.back[1] === 'B' &&
                      faces.left[1] === 'O';
    return whiteCross && sideColors;
  }

  // 检查底层角块
  static checkBottomCorners(state: string): boolean {
    const faces = parseCubeState(state);
    // 检查白色面所有块
    const whiteComplete = faces.up.split('').every(color => color === 'W');
    // 检查四周第一层颜色正确
    const sidesCorrect = faces.front[0] === 'G' && faces.front[2] === 'G' &&
                        faces.right[0] === 'R' && faces.right[2] === 'R' &&
                        faces.back[0] === 'B' && faces.back[2] === 'B' &&
                        faces.left[0] === 'O' && faces.left[2] === 'O';
    return whiteComplete && sidesCorrect;
  }

  // 匹配魔方状态模式
  private static matchPattern(state: string, pattern: string[]): boolean {
    // 将模式转换为正则表达式
    // x 表示任意颜色，其他字母必须精确匹配
    const regexPattern = pattern.map(face => 
      new RegExp(face.replace(/x/g, '[WOGRBY]'))
    );
    
    // 检查每个面是否匹配对应的模式
    for (let i = 0; i < 6; i++) {
      const facePart = state.slice(i * 9, (i + 1) * 9);
      if (!regexPattern[i].test(facePart)) {
        return false;
      }
    }
    return true;
  }
}
```获取完整解法步骤序列
  ```python
  # 示例返回格式
  {
    "steps": ["R", "U", "R'", "U'", ...],  # 完整的解法步骤
    "total_moves": 20  # 总步数
  }
  ```
- `solve_cube`：获取最终还原状态
  ```python
  # 示例返回格式
  {
    "solved_state": {
      "front": ["white", ...],
      "up": ["yellow", ...],
      # ... 其他面的状态
    }
  }
  ```

### 2. 前端目录结构
```
src/
├── components/          # UI组件
│   ├── Cube3D.tsx      # 3D魔方渲染
│   ├── SolvingGuide.tsx # 解法引导界面
│   └── ControlPanel.tsx # 控制面板
├── services/
│   └── cubeApi.ts      # 后端接口调用
├── utils/
│   ├── cubeUtils.ts    # 魔方状态处理
│   └── solvingManager.ts # 解法管理器
└── constants/
    └── solvingSteps.ts  # 分步解法配置
```

---

## 二、分步解法核心逻辑

### 1. 前端状态管理
```typescript
// solvingManager.ts
interface CubeState {
  state: string;  // 54位字符串，表示魔方当前状态
}

interface SolvingState {
  currentStage: number;     // 当前解法阶段
  currentStep: number;      // 当前步骤索引
  totalSteps: number;       // 总步数
  stages: Stage[];         // 解法阶段配置
  formula: string[];       // 完整解法公式
  initialState: string;    // 初始魔方状态
}

interface Stage {
  name: string;           // 阶段名称
  description: string;    // 阶段描述
  startStep: number;      // 起始步骤索引
  endStep: number;       // 结束步骤索引
  status: string;        // 对应的状态标识
  checkComplete: (state: string) => boolean; // 状态检测函数
}

// constants/solvingSteps.ts
const SOLVING_STAGES: Stage[] = [
  {
    name: '底层十字',
    description: '首先完成白色底面的十字',
    startStep: 0,
    endStep: 4,
    status: 'BOTTOM_CROSS',
    checkComplete: (state) => CubeStateAnalyzer.checkBottomCross(state)
  },
  {
    name: '底层角块',
    description: '完成底层四个角块',
    startStep: 5,
    endStep: 8,
    status: 'BOTTOM_CORNERS',
    checkComplete: (state) => CubeStateAnalyzer.checkBottomCorners(state)
  },
  {
    name: '中层边块',
    description: '完成中间层的四个边块',
    startStep: 9,
    endStep: 12,
    status: 'MIDDLE_LAYER',
    checkComplete: (state) => CubeStateAnalyzer.checkMiddleLayer(state)
  },
  // ... 其他阶段
];

### 3. 分步导航与状态检测
- 前端维护当前分步阶段和当前步骤索引。
- 用户每完成一步，前端检测魔方状态（可用 `solve_cube` 校验是否已还原）。
- 判断当前魔方状态是否达到当前分步目标（通过自定义状态检测函数，如判断底层十字是否完成）。

### 4. 用户引导与反馈
- 展示当前分步目标、公式、操作提示。
- 用户操作魔方，前端实时检测状态，若达到目标则进入下一分步。
- 提供“下一步/上一步”导航，允许用户回顾或提前学习。

---

## 三、UI组件设计

### 1. 解法引导界面
```typescript
// components/SolvingGuide.tsx
export function SolvingGuide() {
  const [manager] = useState(() => new SolvingManager());
  const [guide, setGuide] = useState<StageGuide>();
  
  useEffect(() => {
    // 监听魔方状态变化
    return subscribeToStateChange((newState) => {
      if (manager.checkCurrentStageComplete(newState)) {
        manager.moveToNextStage();
      }
      setGuide(manager.getCurrentStageGuide());
    });
  }, []);

  return (
    <div className="solving-guide">
      {/* 阶段进度指示器 */}
      <StageProgress 
        currentStage={guide.stageName} 
        progress={guide.progress} 
      />
      
      {/* 当前步骤说明 */}
      <StageDescription 
        description={guide.description} 
      />
      
      {/* 公式显示 */}
      <FormulaDisplay 
        formula={guide.currentFormula} 
      />
      
      {/* 操作控制 */}
      <ControlButtons 
        onPrev={manager.prevStep} 
        onNext={manager.nextStep}
        onAuto={manager.autoPlay} 
      />
    </div>
  );
}
```

### 2. 解法阶段定义

基于标准魔方还原顺序，将解法分为以下阶段：

1. 底层十字（白色面）
   - 检查点：白色面的十字完成
   - 状态检测：检查白色面的上下左右四个位置
   - 索引范围：0-4步

2. 底层角块（白色面）
   - 检查点：白色面的四个角块完成
   - 状态检测：检查白色面的四个角位置
   - 索引范围：5-8步

3. 中层边块
   - 检查点：四个中层棱块就位
   - 状态检测：检查四个中层边块位置
   - 索引范围：9-12步

4. 顶层十字（黄色面）
   - 检查点：黄色面的十字完成
   - 状态检测：检查黄色面的上下左右四个位置
   - 索引范围：13-16步

5. 顶层边块（黄色面）
   - 检查点：黄色面的边块正确
   - 状态检测：检查黄色面的四个边块
   - 索引范围：17-20步

6. 顶层角块（最后一步）
   - 检查点：整个魔方还原完成
   - 状态检测：检查最终状态是否匹配目标状态
   - 索引范围：21步及以后

### 3. UI界面布局草图
```
+--------------------------------+
|           魔方3D显示            |
|                                |
|     [可交互的3D魔方模型]        |
|                                |
+--------------------------------+
|         解法引导面板            |
| +----------------------------+ |
| | 阶段：底层十字 (1/6)        | |
| | 描述：完成白色底面的十字     | |
| | 公式：F R U R' U' F'       | |
| |                            | |
| | [上一步] [自动] [下一步]    | |
| +----------------------------+ |
+--------------------------------+
|         操作控制面板           |
| [重置] [撤销] [自动演示] [帮助] |
+--------------------------------+
```---

## 四、数据流转与状态管理

### 1. 数据流转图
```
后端 (Python Service)          前端 (React/Vite)
     |                             |
     |                             |
     |   1. get_solution()         |
     | <------------------------   |
     |                             |
     |   返回完整解法步骤           |
     | ----------------------->    |
     |                             |
     |   2. solve_cube()          |
     | <------------------------   |
     |                             |
     |   返回还原状态用于校验       |
     | ----------------------->    |
     |                             |
```

### 2. 状态管理流程
```
用户操作 -----> 魔方状态更新 -----> 检查当前阶段完成
                                   |
                                   v
                          是 --> 进入下一阶段
                                   |
                                   v
                             更新UI显示
                                   |
                                   v
                             等待用户操作
```

## 五、实现步骤建议

1. 后端接口调整（无需修改）
   - 保持现有的 `get_solution` 和 `solve_cube` 接口不变

2. 前端实现顺序
   - 实现 `SolvingManager` 类
   - 完善 `solvingSteps.ts` 中的阶段定义
   - 开发 UI 组件（SolvingGuide、StageProgress 等）
   - 实现状态检测函数
   - 添加动画和交互效果

3. 测试计划
   - 接口集成测试
   - 状态检测函数单元测试
   - UI 组件渲染测试
   - 完整解法流程测试

## 六、扩展性考虑

1. 可扩展项
   - 添加更多解法策略
   - 支持自定义阶段划分
   - 增加详细的教学提示
   - 添加练习模式

2. 性能优化
   - 状态检测函数缓存
   - 解法步骤预加载
   - 3D 渲染优化

## 三、简化总结

### 1. 核心简化
- 直接使用字符串索引进行状态检测
- 减少状态解析和转换步骤
- 简化进度追踪和反馈机制
- 最小化UI组件和交互流程

### 2. 主要优势
- 代码量大幅减少
- 逻辑更直观易懂
- 维护成本降低
- 性能开销更小

### 3. 使用流程
1. 获取魔方当前状态字符串
2. 使用CubeChecker检查进度
3. 更新UI显示当前进度
4. 提示用户下一步操作
